use sha1::Sha1;
use signature::Verifier;

#[cfg(feature = "fixed-bigint")]
use fixed_bigint::FixedUInt;
use rsa_generic::pss::VerifyingKey;
use rsa_generic::RsaPublicKey;

#[cfg(feature = "fixed-bigint")]
#[test]
fn test_verify_512_bit() {
    let data = b"hello world!";
    let modulus: [u8; 64] = [
        0x96, 0x9D, 0x03, 0xFF, 0xA9, 0x8D, 0x88, 0x8F, 0x3A, 0xA4, 0xF2, 0xFE, 0xD2, 0x32, 0xE6,
        0x1C, 0x4A, 0xCF, 0x06, 0x63, 0xA9, 0x2F, 0x99, 0x03, 0x4C, 0xF7, 0xB7, 0x24, 0x5A, 0x1A,
        0x1E, 0x5E, 0xAF, 0xA5, 0x65, 0xAF, 0xB9, 0x0B, 0xAB, 0x22, 0x85, 0x71, 0x2F, 0xAA, 0x50,
        0x39, 0x39, 0xA0, 0x65, 0xFB, 0x60, 0xDD, 0x08, 0x28, 0xA3, 0x84, 0xF2, 0x6D, 0x8A, 0xFC,
        0x28, 0x6D, 0xF6, 0xCF,
    ];
    let signature: [u8; 64] = [
        0x8B, 0x79, 0x04, 0xF1, 0x59, 0xBE, 0x77, 0x50, 0x11, 0x0D, 0x99, 0x2C, 0xDA, 0x76, 0x49,
        0x0A, 0x47, 0xC5, 0x9E, 0x1F, 0xA5, 0xEB, 0xAB, 0xE7, 0x98, 0xC6, 0x48, 0x3F, 0x2E, 0x4F,
        0x00, 0xD1, 0x89, 0x6C, 0x42, 0xE4, 0x36, 0x46, 0xE1, 0xB8, 0x84, 0x83, 0xAA, 0x03, 0xFB,
        0xED, 0x72, 0x85, 0x36, 0xF9, 0x1D, 0xBF, 0xB4, 0xF7, 0xF8, 0x8F, 0xC0, 0x5D, 0xCA, 0x82,
        0xFD, 0xFE, 0xA1, 0x1D,
    ];
    let n = FixedUInt::<u32, 16>::from_be_bytes(&modulus);
    let key = RsaPublicKey::new(n, 3u8.into()).unwrap();
    let refme: &[u8] = signature.as_ref();
    let sig = refme.try_into().unwrap();
    let verifying_key = VerifyingKey::<Sha1, _>::new(key);
    verifying_key.verify(data, &sig).expect("failed to verify");
}
